""""""
"""
Tuples can be used as immutable lists and records with no fields name.

A tuple uses less memory than a list of the same length, and it allows Python to do some optimizations.

Be aware that the immutability of a tuple only applies to the references contained in it. References in a tuple cannot 
be deleted or replaced. But if one of those references points to a mutable object, and that object is changed, then the 
value of the tuple changes.

An object is only hashable if its value cannot ever change. An unhasha‐ble tuple cannot be inserted as a dict key, 
or a set element.

Tuples performance:
- To evaluate a tuple literal, the Python compiler generates bytecode for a tuple constant in one operation, but for a 
  list literal, the generated bytecode pushes each element as a separate constant to the data stack, and then builds 
  the list.
- Given a tuple t, tuple(t) simply returns a reference to the same t. There’s no need to copy. In contrast, given a 
  list l, the list(l) constructor must create a new copy of l.
- Because of its fixed length, a tuple instance is allocated the exact memory space it needs. Instances of list, on the 
  other hand, are allocated with room to spare, to amortize the cost of future appends.
- The references to the items in a tuple are stored in an array in the tuple struct, while a list holds a pointer to an 
  array of references stored elsewhere. The indirection is necessary because when a list grows beyond the space 
  currently allocated, Python needs to reallocate the array of references to make room. The extra indirection makes CPU 
  caches less effective.
"""

# Example:
a = (10, 'alpha', [1, 2])
b = (10, 'alpha', [1, 2])
print(a == b)
b[-1].append(99)
print(a == b)
print(b)

"""
Create a function that determines if a tuple (or any object) as a fixes value:
"""
def fixed(o):
    try:
        hash(o)
    except TypeError:
        return False
    return True

tf = (10, 'alpha', (1, 2))
tm = (10, 'alpha', [1, 2])
print(fixed(tf))
print(fixed(tm))

